3. class文件的格式

## 3.1 .class文件的结构

一个类文件由如下结构组成：

```java
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

### 3.1.1 Magic（魔术值）

&emsp;&emsp; 在类的装载阶段用于验证这个文件是不是Java的类文件，这通常是第一关，通常值为0xCA FE BA BE（PS:咖啡宝贝，Java的logo就是一杯咖啡），等于十进制的 3405691582 。

### 3.1.2 minor_version（次要版本）,major_version（主要版本）

&emsp; &emsp;主要是查看当前的JVM能否加载这个类文件，如果是高版本的JDK编译的类文件，那么低版本的JVM就无法加载。

&emsp;&emsp; 且会抛出**java.lang.UnsupportedClassVersionError**。

### 3.1.3 constant_pool_count（常量池计数）

&emsp; &emsp;这个类文件中常量池的总数。

### 3.1.4 constant_pool[constant_pool_count1]（常量池）

&emsp; &emsp;常量池，这个可以看做索引从1开始的数组，这就解释了，为什么他要比常量池计数少一个。

### 3.1.5 access_flags（访问标识符）

&emsp;&emsp;标记这个字节码文件是什么成分，是一个接口？还是一个枚举？是final还是public修饰？

**标识符对应的16进制**

| **标记名称**       | **16进制值** | **说明**                            |
|----------------|-----------|-----------------------------------|
| ACC_PUBLIC     | 0x0001    | 关键字public的特性                      |
| ACC_FINAL      | 0x0010    | 关键字final的特性                       |
| ACC_SUPER      | 0x0020    | 当被invokespecial指令调用时，会对父类方法作特殊处理。 |
| ACC_INTERFACE  | 0x0200    | 这是一个接口                            |
| ACC_ABSTRACT   | 0x0040    | 这是一个抽象的                           |
| ACC_SYNTHETIC  | 0x1000    | synthetic，由编译器产生，源码中不存在           |
| ACC_ANNOTATION | 0x2000    | 这是一个注解                            |
| ACC_ENUM       | 0x4000    | 这是一个枚举                            |

### 3.1.6 this_class（当前字节码）

&emsp;&emsp;当前字节码文件，必须是constant_pool中的有效索引，且该索引处的结构应该是一个Constant_Class_info结构，用来表示这个字节码文件是个类还是个接口。

### 3.1.7 super_class（父类）

&emsp;&emsp;对于任何一个类，它的super_class只有两种情况：

&emsp;&emsp;1）**为0的时候**

&emsp;&emsp;此时这个this_class必定是java.lang.Object，这是唯一没有父类的类或者接口。

&emsp;&emsp;2）**不为0的时候**

&emsp;&emsp;此时这个super_class指向的constant_pool中的有效索引，且该索引处的结构应该是一个Constant_Class_info结构，且这个super_class的Class_File结构中的access_flags （访问标识符）项不能有ACC_FINAL这个标识符，因为final修饰的类是太监类，不允许有子类。

&emsp;&emsp;接口interface的super_class怎么表示呢？当然接口的super_class必定是constant_pool里面的有效索引，且对应的结构也必定是Object的Constant_Class_info结构。

&emsp;&emsp;**坑逼面试题来了，综上所述接口的父类就是Object？**

&emsp;&emsp;当然不是，从学JavaSE开始接口就是没得父类的，那为啥子这里的super_class还要指定Object？这个链接讲述的很好：[点击我](https://stackoverflow.com/questions/68874966/interfaces-implicitly-declaring-public-methods-of-object-class)。

```java
public interface A {
}
A a = new A(){};
a.hashCode();
```

&emsp;&emsp;如上面例子所示，这个对象a为什么可以调用Object里面的hashCode方法？本质上是接口帮我们做了一层抽象，只是悄悄的给我们提供了这些方法，使得Object类里面的方法可以传递给我们， Java在设计的时候就是要确保所有的对象都能调用Object里面的方法。如果不这样设计，那我每个接口都要去添加那些实现重复的方法，例如hashCode、equals等等方法，这样是不利于开发人员的。所以接口的super_class才会指定到Object帮我们完成这件事。

### 3.1.8 interfaces_count

&emsp;&emsp;表示了该类实现的接口数量或者是该接口继承的接口数量。

### 3.1.9 interfaces[interfaces_count]

### 3.1.10 fields_count

### 3.1.11 fields[]

### 3.1.12 methods_count（方法总数）

### 3.1.13 methods[]

### 3.1.14 attributes_count

### 3.1.15 attributes[]

## 3.2 名称的内部表达形式

### 3.2.1 类和接口名称的二进制表达形式

&emsp;&emsp;出现在字节码文件中的类和接口名称始终以二进制的全限定名形式表示，结构始终为Constant_UTF8_INFO结构。而Constant_NameAndType_INFO又会指向这个二进制表述，从而得到这个字段或者方法的名称。

&emsp;&emsp;历史原因导致，以 （. .）作为分割符号的ASCLL符号在字节码文件中会被替换成 ASCLL的正斜杠 /。

&emsp;&emsp;例如：Thread类全限定名的正常表述为java.lang.Thread，但是在字节码文件中使用的是Constant_UTF8_INFO结构二进制编码表示的java/lang/Thread。

### 3.2.2 非限定名

&emsp;&emsp;在Java中非限定名称就是不包含包名的名称，字段名称、方法名称、局部变量名称和形参名称都是非限定名。非限定名称必须至少包含一个Unicode码点（说人话就是必须要有值），并且不得包含任何英文句号、分号、左方括号或者正斜杠的ASCLL字符。

&emsp;&emsp;除了特殊方法名称<init>和<clinit>以外，其他方法名称不得包含左尖括号（<）和右尖括号（>）的ASCLL字符。

&emsp;&emsp;注意：字段名称或接口方法名称可能是<init>或<clinit>，但是没有方法指令去调用<clinit>，只有invokespecial指令可以调用<init>。

//TODO 这里的init拿来干嘛？clinit又是干嘛的。

## 3.3 描述符

&emsp;&emsp;描述符就是表示字段或者是方法类型的字符串。描述符采用UTF-8缩略编码的格式进行表示。

### 3.3.1 字段描述符

&emsp;&emsp;字段描述符用于表示类、示例或者局部变量的类型。

&emsp;&emsp; 字段类型由三种类型构成BaseType（基本数据类型）、ObjctType（引用数据类型）、ArrayType（数组类型）。在字节码中用于标注字段类型的代号都是ASCLL字符。

